"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_error_report_1 = require("@vtex/node-error-report");
const __1 = require("..");
const utils_1 = require("../utils");
class ErrorReport extends node_error_report_1.ErrorReportBase {
    static create(args) {
        return new ErrorReport(node_error_report_1.createErrorReportBaseArgs(args));
    }
    injectOnSpan(span, logger) {
        var _a;
        span.setTag(__1.TracingTags.ERROR, 'true');
        span.setTag(__1.TracingTags.ERROR_KIND, this.kind);
        if (node_error_report_1.isRequestInfo(this.parsedInfo) &&
            this.parsedInfo.response &&
            node_error_report_1.isInfraErrorData((_a = this.parsedInfo.response) === null || _a === void 0 ? void 0 : _a.data)) {
            span.setTag(__1.TracingTags.ERROR_SERVER_CODE, this.parsedInfo.response.data.code);
            span.setTag(__1.TracingTags.ERROR_SERVER_SOURCE, this.parsedInfo.response.data.source);
            span.setTag(__1.TracingTags.ERROR_SERVER_REQUEST_ID, this.parsedInfo.response.data.requestId);
        }
        span.log({ event: 'error', ...this.toObject() });
        if (logger && this.shouldLogToSplunk(span)) {
            logger.error(this.toObject());
            this.markErrorAsReported();
        }
        return this;
    }
    shouldLogToSplunk(span) {
        return this.isErrorReported() && utils_1.getTraceInfo(span).isSampled;
    }
}
exports.ErrorReport = ErrorReport;
